---

layout: post

categories: fun

published: true

invisible: true

---

# Вертикальный текст

Некоторое время назад я уже делился этой штукой в твиттере, но на этот раз хочу написать о нём немного подробнее.

Задача: получить повёрнутый на 90 градусов текст. Проблема: всем известно, что если использовать `transform`, то блок ведёт себя аналогично сдвигу через `position: relative` — продолжает занимать место в потоке подобно состоянию до трансформации, так что, по факту, изменение происходит только визуальное.

Однако, довольно часто может возникнуть необходимость повернуть блок так, чтобы этот поворот оказал внимание и на поток. Например, если мы захотим выстроить ряд элементов в ряд, подобно книгам на полке, или же если мы захотим использовать повёрнутый текст в качестве заголовков таблицы – в этих случаях нам нужно будет, во-первых, гарантировать, что по высота станет равна ширине блока, в то время как ширина — станет равной высоте.

У меня получилось решить эту задачу с одним упрощением — мы должны знать высоту поворачиваемого элемента. В этом случае реализация становится предельно простой.

1. Нам понадобится дополнительный элемент. Т.е. каждый блок, который мы хотим повернуть, будет примерно таким:

        <span class="vertical-text">
            <span class="vertical-text__inner">
                Rotated foo
            </span>
        </span>
    {:.language-markup}

2. Врапперу мы задаём следующие стили: 

        .vertical-text {
            display: inline-block;
            overflow: hidden;
            width: 1.5em;
            line-height: 1.5;
        }
    {:.language-css}

    Здесь мы делаем элемент инлайн-блочным (это не критично, сработало бы и блочное отображение, но инлайн-блок пригодится чаще), затем обрезаем все выступающие части (нужно будет в дальнейшем), далее задаём ширину, равную текущей высоте блока (`line-height` тут приведён в качестве примера того, что сейчас определяет высоту блока, а так как все элементы, используемые в примере, однострочные, то это и будет его высотой).

3. Внутренний элемент делаем инлайн-блочным, чтобы его ширина схлопнулась по контенту. После чего задаём `white-space: nowrap` для того, чтобы ничего никуда не переносилось (ведь выше мы ограничили ширину), ну и поворачиваем блок, считая верхний левый угол точкой отсчёта (свойства приведены без префиксов для упрощения):

        .vertical-text__inner {
            display: inline-block;
            white-space: nowrap;
            transform: translate(0,100%) rotate(-90deg);
            transform-origin: 0 0;
        }
    {:.language-css}

4. А теперь самое главное: нам нужно сделать этот внутренний элемент «квадратным» — это сделает высоту конечного элемента равной ширине, ну а ширина у нас обрезается враппером. Для того, чтбы сделать наш элемент квадратным я применяю вот такой вот трюк:

        .vertical-text__inner:after {
            content: "";
            float: left;
            margin-top: 100%;
        }
    {:.language-css}

    Вроде всё довольно просто, но не многие знают о том, что вертикальные маджины и паддинги, заданные в процентах, исчисляются не от высоты блока, а от его ширины. Флоат делает этот псевдоэлемент нулевой ширины (ну и заодно делает его не инлайновым), а маджин растягивает элемент до квадрата.

[demo:vertical-text]
